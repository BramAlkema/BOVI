/**
 * BOVI Smart Contract Templates
 * Off-chain contracts with PDF receipts
 */

import { jsPDF } from "jspdf";

export interface ContractClause {
  ltsIndex: string; // Reference to LTS ruler
  capBp?: number; // Cap in basis points
  floorBp?: number; // Floor in basis points
  carry: boolean; // Carry over unused adjustments
  undoWindowHours: number;
}

export interface SmartContract {
  id: string;
  templateId: string;
  parties: string[];
  clause: ContractClause;
  humanReadable: string;
  created: string;
  effectiveFrom: string;
  undoDeadline: string;
  signed: boolean;
}

/**
 * Create contract from template with LTS indexation
 */
export async function createSmartContract(
  templateId: "rent" | "salary" | "loan",
  parties: string[],
  clause: ContractClause
): Promise<{ contract: SmartContract; receipt: { pdf: Blob; json: string } }> {
  const templates = {
    rent: "Annual rent adjustment shall be the lesser of LTS inflation or {cap}%, with a floor of {floor}% decrease.",
    salary: "Annual salary review based on LTS inflation, capped at {cap}% increase.",
    loan: "Variable rate tied to LTS inflation + {margin}%, with {floor}% minimum rate.",
  };

  const contract: SmartContract = {
    id: `contract_${Date.now()}`,
    templateId,
    parties,
    clause,
    humanReadable: templates[templateId]
      .replace("{cap}", ((clause.capBp || 0) / 100).toString())
      .replace("{floor}", ((clause.floorBp || 0) / 100).toString()),
    created: new Date().toISOString(),
    effectiveFrom: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // Tomorrow
    undoDeadline: new Date(Date.now() + clause.undoWindowHours * 60 * 60 * 1000).toISOString(),
    signed: false,
  };

  // Generate receipts
  const pdfReceipt = await generatePDFReceipt(contract);
  const jsonReceipt = JSON.stringify(contract, null, 2);

  // Store contract
  const contracts = JSON.parse(localStorage.getItem("bovi.smartContracts") || "[]");
  contracts.push(contract);
  localStorage.setItem("bovi.smartContracts", JSON.stringify(contracts));

  return {
    contract,
    receipt: {
      pdf: pdfReceipt,
      json: jsonReceipt,
    },
  };
}

/**
 * Generate PDF receipt for contract
 */
async function generatePDFReceipt(contract: SmartContract): Promise<Blob> {
  const doc = new jsPDF();
  
  // Header
  doc.setFontSize(18);
  doc.setFont("helvetica", "bold");
  doc.text("BOVI Smart Contract Receipt", 20, 30);
  
  // Add BOVI logo placeholder
  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");
  doc.text("Generated by BOVI Framework â€¢ Off-chain Contract System", 20, 40);
  
  // Contract details
  doc.setFontSize(12);
  doc.setFont("helvetica", "bold");
  doc.text("Contract Details", 20, 60);
  
  doc.setFont("helvetica", "normal");
  let yPos = 75;
  
  const details = [
    [`Contract ID:`, contract.id],
    [`Template Type:`, contract.templateId.toUpperCase()],
    [`Parties:`, contract.parties.join(", ")],
    [`Created:`, new Date(contract.created).toLocaleString()],
    [`Effective From:`, new Date(contract.effectiveFrom).toLocaleString()],
    [`Undo Deadline:`, new Date(contract.undoDeadline).toLocaleString()]
  ];
  
  details.forEach(([label, value]) => {
    doc.setFont("helvetica", "bold");
    doc.text(label, 20, yPos);
    doc.setFont("helvetica", "normal");
    doc.text(value, 65, yPos);
    yPos += 8;
  });
  
  // Contract terms
  yPos += 10;
  doc.setFontSize(12);
  doc.setFont("helvetica", "bold");
  doc.text("Contract Terms", 20, yPos);
  
  yPos += 10;
  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");
  
  // Split long text into lines
  const terms = doc.splitTextToSize(contract.humanReadable, 170);
  doc.text(terms, 20, yPos);
  yPos += terms.length * 5 + 10;
  
  // Technical parameters
  doc.setFontSize(12);
  doc.setFont("helvetica", "bold");
  doc.text("Technical Parameters", 20, yPos);
  
  yPos += 10;
  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");
  
  const params = [
    [`LTS Index Reference:`, contract.clause.ltsIndex],
    [`Cap (basis points):`, contract.clause.capBp?.toString() || "No cap"],
    [`Floor (basis points):`, contract.clause.floorBp?.toString() || "No floor"],
    [`Carryover Unused Adjustments:`, contract.clause.carry ? "Yes" : "No"],
    [`Undo Window:`, `${contract.clause.undoWindowHours} hours`]
  ];
  
  params.forEach(([label, value]) => {
    doc.setFont("helvetica", "bold");
    doc.text(label, 20, yPos);
    doc.setFont("helvetica", "normal");
    doc.text(value, 80, yPos);
    yPos += 6;
  });
  
  // Footer
  yPos += 20;
  doc.setFontSize(8);
  doc.setTextColor(100);
  doc.text("This is an off-chain smart contract managed by the BOVI Framework.", 20, yPos);
  doc.text(`Generated: ${new Date().toISOString()}`, 20, yPos + 5);
  doc.text("For more information: https://bramalkema.github.io/BOVI/", 20, yPos + 10);
  
  // Convert to blob
  const pdfBlob = doc.output("blob");
  return pdfBlob;
}

/**
 * Download PDF receipt
 */
export function downloadPDFReceipt(pdfBlob: Blob, contractId: string): void {
  const url = URL.createObjectURL(pdfBlob);
  const link = document.createElement("a");
  link.href = url;
  link.download = `BOVI_Contract_${contractId}.pdf`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Get all smart contracts from storage
 */
export function getStoredContracts(): SmartContract[] {
  try {
    const contracts = JSON.parse(localStorage.getItem("bovi.smartContracts") || "[]");
    return contracts;
  } catch (error) {
    console.warn("Failed to parse stored contracts, returning empty array:", error);
    return [];
  }
}

/**
 * Sign a contract
 */
export function signContract(contractId: string): boolean {
  const contracts = getStoredContracts();
  const contract = contracts.find(c => c.id === contractId);
  
  if (!contract) return false;
  
  contract.signed = true;
  localStorage.setItem("bovi.smartContracts", JSON.stringify(contracts));
  return true;
}

/**
 * Check if contract can be undone
 */
export function canUndoContract(contractId: string): boolean {
  const contracts = getStoredContracts();
  const contract = contracts.find(c => c.id === contractId);
  
  if (!contract) return false;
  
  return new Date() < new Date(contract.undoDeadline);
}

/**
 * Undo a contract within the window
 */
export function undoContract(contractId: string): boolean {
  if (!canUndoContract(contractId)) return false;
  
  const contracts = getStoredContracts();
  const filteredContracts = contracts.filter(c => c.id !== contractId);
  localStorage.setItem("bovi.smartContracts", JSON.stringify(filteredContracts));
  return true;
}
